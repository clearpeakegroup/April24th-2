import os
import asyncio
from slack_bolt.async_app import AsyncApp
from slack_sdk.errors import SlackApiError
from twilio.rest import Client as TwilioClient
from dotenv import load_dotenv
from loguru import logger

load_dotenv()
SLACK_BOT_TOKEN = os.getenv("SLACK_BOT_TOKEN")
SLACK_SIGNING_SECRET = os.getenv("SLACK_SIGNING_SECRET")
TWILIO_SID = os.getenv("TWILIO_SID")
TWILIO_TOKEN = os.getenv("TWILIO_TOKEN")
TWILIO_FROM = os.getenv("TWILIO_FROM")
TWILIO_TO = os.getenv("TWILIO_TO")

app = AsyncApp(token=SLACK_BOT_TOKEN, signing_secret=SLACK_SIGNING_SECRET)

def get_today_csv():
    # Path to today's trade CSV (should be generated by trading logic)
    from datetime import datetime
    fname = f"risk/pnl_csv/pnl_{datetime.utcnow().strftime('%Y%m%d')}.csv"
    if os.path.exists(fname):
        return fname
    return None

@app.message("!audit today")
async def handle_audit_today(message, say):
    fname = get_today_csv()
    if fname:
        await say(f"Today's trade CSV:", files=[fname])
    else:
        await say("No trade CSV found for today.")

@app.message("/kill all")
async def handle_kill_all(message, say):
    # Implement flatten + pause logic (stub)
    await say("All heads flattened and paused.")
    logger.warning("/kill all invoked: trading paused.")

async def send_critical_alert(text):
    try:
        # Slack DM
        await app.client.chat_postMessage(channel="@admin", text=text)
    except SlackApiError as e:
        logger.error(f"Slack DM failed: {e}")
    try:
        # Twilio SMS
        client = TwilioClient(TWILIO_SID, TWILIO_TOKEN)
        client.messages.create(body=text, from_=TWILIO_FROM, to=TWILIO_TO)
    except Exception as e:
        logger.error(f"Twilio SMS failed: {e}")

# Example usage: await send_critical_alert("CRITICAL: Trading halted due to risk limit.")

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8080) 